출력 메소드 	: 오류 구체화
변수		: 저장공간
자료형		: boolean(1), byte, short, int(4), float(4), double(8), char(2), String(?)
형변환		: 문자 + 정수 = 정수
입력 메소드	:
연산자		: 최단산쉬관리삼대, 결합성
제어문		: 조건문, 반복문(for : 반복 횟수를 알 때, while: 반복 횟수를 모를 때)
배열		: 저장공간의 나열, 시작 주소, 인덱스 0부터 시작이유: 배열은 시작주소를 가지고 있으니까
			[], 1.여러 칸 만들기, 2. 규칙성 부여
메소드		: 이름 뒤에 소괄호, 저장공간, 저장공간에는 소스코드의 주소값이 들어감, 매개변수? 화면에서 입력받은 값을 전달받는 공간
클래스		: 반, 한 번씩만 선언하기 위해서, 재사용, 1. 타입이다. 2. 주어이다, 추상적이다.
		  추상적인 개념을 구체화시키는 작업(객체화-instance), 객체화를 통해 나온 변수(객체- 주소값)
		  추상적인 개념으로 필드에 접근할 수 없다. 필드를 메모리에 올리기 위해서는 생성자가 필요
		  생성자: 클래스이름(), 생성자는 필드를 초기화할 수 있다.
		  this. -> 필드에 접근한 객체의 주소를 담는 변수
	   	  this() : 자기 자신의 생성자
다형성		: 오버로딩: 메소드 이름은 같은데, 매개변수가 다름
		  오버라이딩: 재정의, 무시하다, 부모꺼 무시하고 자식꺼 사용
		  부모 필드가 먼저 생성, 자식 필드가 나중에 생성
상속(inheritance)	: 1. 기존에 있는 클래스의 필드를 쓸 때 2. 만들다보니 공통요소가 많아서 부모 선언
		  super : 부모 필드, 부모 클래스
		  super() : 부모 생성자
Casting		: up casting, down casting
		 부모 타입에 자식값을 집어넣으면 up
		 up된 객체를 다시 자식 타입으로 복원할 때 down
추상클래스	: 추상메소드를 필드로 가지고 있는 클래스, abstract
인터페이스	: 틀, 추상클래스를 고도화시킨 문법, implements, 인터페이스의 필드는 구현이 안되어있다.
마커인터페이스	: 그룹화, 
내부클래스	
익명클래스	: 이름이 없는 클래스, 필드를 구현하기 위해 사용
함수형 인터페이스	: 한 개의 추상메소드를 선언, 메소드를 구현할 때 이름을 안쓰려고
람다식		: 이름이 없는 메소드(익명 메소드)
